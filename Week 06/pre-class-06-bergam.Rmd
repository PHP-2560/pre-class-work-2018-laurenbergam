# pre-class


Make sure you commit this often with meaningful messages. 



```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


1. Read the source code for each of the following three functions, puzzle out what they do, and then brainstorm better names.

```{r}

string_a <- c(1,2,3,4,5)
prefix_a <- 3

string_b <- c("This", "is", "an", "amazing", "string")
prefix_b <- "is"

#Iterates through each value in string, if equal to prefix, print TRUE, if not, print FALSE
string_contains_prefix <- function(string, prefix) {
  substr(string, 1, nchar(prefix)) == prefix
}

#Test:
string_contains_prefix(string_b, prefix_b)

```

```{r}

a <- c(1,2,3,5,43,56,7,7,4)
  
  
#Removes last element in sequence if sequence contains more than one element
remove_last_element <- function(x) {
  if (length(x) <= 1) return(NULL)
  x[-length(x)]
}

#Test:
remove_last_element(a)

```

```{r}

b <- c(1,2,3,4,5,6,7,8,9)
c <- c(4,5,6,6,7,8)

#Repeats second list until it is the length of the first list
repeat_equal_lengths <- function(x, y) {
  rep(y, length.out = length(x))
}

#Test
repeat_equal_lengths(b,c)

```

2. Compare and contrast rnorm() and MASS::mvrnorm(). How could you make them more consistent?

Both rnorm and mvrnorm draw random numbers from the normal distribution. However, rnorm draws numbers from a univariate normal distribution, that is, drawn numbers would produce a normally distributed histogram. While mvrnorm draws numbers from more than one variate, ie drawn numbers from a bivariate normal distribution would produce a normally distributed 3D graph. 

These functions have inconsistent labeling since rnorm defines the mean as "mean" and the standard deviation as "sd", while mvrnorm defines the means as "mu" and the covariance as "Sigma" since covariance is considered the standard deviation (or variance) of multiple dimensions. To make these functions more consistent, their arguments could be defined by the same labels. 

```{r}
#install.packages("MASS")
#library(MASS)


Sigma <- matrix(c(10,3,3,2),2,2)
Sigma
var(mvrnorm(n = 100, rep(0, 2), Sigma))
var(mvrnorm(n = 100, rep(0, 2), Sigma, empirical = TRUE))


rnorm(n = 100, rep(0, 2), Sigma)

rnorm(sigma)

```
3. Use `lapply()` and an anonymous function to find the coefficient of variation (the standard deviation divided by the mean) for all columns in the mtcars dataset. 
```{r}

#Define function with one argument which will be the dataframe to input
#Use function using lapply to iterate 
#Turn the listed output into a dataframe by using brackets with mtcars
variation_coeff <- function(x) sd(x)/mean(x)
mtcars[] <- lapply(mtcars, variation_coeff)


```

4. Use vapply() to:
    a. Compute the standard deviation of every column in a numeric data frame.
```{r}


```
    b. Compute the standard deviation of every numeric column in a mixed data frame. (Hint: you'll need to use vapply() twice.)
```{r}


```